#!/usr/bin/python
from astropy.io import fits
import numpy as np
from astropy.wcs import WCS
from astropy.nddata import Cutout2D
import os.path
from argparse import ArgumentParser
import ephem
import time
from datetime import datetime, timedelta
from scipy import stats
from scipy.stats import norm
from scipy.optimize import leastsq,curve_fit,minimize
from scipy import special


##custom 
from mwassa.imginfo import info
from mwassa.curvefitting import skew_norm_pdf, reqCDF, cumulative_distribution_function, getSeedValue, getFloodfillValue
from mwassa.plotting import intialiseMatplotib




def floodfill(x,y,floodfillValue,diff,imgSize):
    if diff[x,y] >= floodfillValue and binaryMap[x,y] ==0:
        binaryMap[x,y] =1
        binaryMaptemp[x,y] =1
        if 1<x<(imgSize-1) and 1<y<(imgSize-1):
            floodfill(x+1,y,floodfillValue,diff,imgSize)
            floodfill(x,y+1,floodfillValue,diff,imgSize)
            floodfill(x-1,y,floodfillValue,diff,imgSize)
            floodfill(x,y-1,floodfillValue,diff,imgSize)
            floodfill(x-1,y-1,floodfillValue,diff,imgSize)
            floodfill(x+1,y-1,floodfillValue,diff,imgSize)
            floodfill(x-1,y+1,floodfillValue,diff,imgSize)
            floodfill(x+1,y+1,floodfillValue,diff,imgSize)
    return



def main():
	parser = ArgumentParser("Flagger", description="Flagges and plots DSNRS for RFI")
	parser.add_argument('--obs', required=True, help="The observation id")
	parser.add_argument('--freqChannels', required=True,type=int, help="Number of frequency channels to process")
	parser.add_argument('--timeStep', required=True, type=int, help="The timestep at which RFISeeker runs")
	parser.add_argument('--seedSigma', default=8, help="The sigma threshold for RFI seeding" )
	parser.add_argument('--floodfillSigma', default=3, help="The sigma upto which flood fill happens")
	parser.add_argument('--debug', default=False, type=bool,help="Prints out more values and shows figure if ran in debug mode")
	parser.add_argument('--plotSatellites', default=False,type=bool,help="Plots the location of the starlink constellation in a different color")
	parser.add_argument('--imgSize',required=False, type=int, help="The size of the images")
	parser.add_argument('--prefix',required=False,help="The prefix used in the ouputfiles")
	args = parser.parse_args()
	debug = args.debug

        imgSize, wcs, header = info(str(args.obs) + "-2m-" + str(0) + "-" + str(0).zfill(4) + "-dirty.fits")
        plt = intialiseMatplotib(debug)

        #below array saves info of all the detections in a given timeStep
        global binaryMap
        binaryMap = np.zeros((imgSize,imgSize))

        timeStep = args.timeStep



        for f in range(args.freqChannels):

            if debug is True:
                print("Working in frequency channel " + str(f+1) + "/" + str(args.freqChannels))

            hdu1 = fits.open(str(args.obs) + "-2m-" + str(timeStep) + "-" + str(f).zfill(4) + "-dirty.fits")
            hdu2 = fits.open(str(args.obs) + "-2m-" + str(timeStep+1) + "-" + str(f).zfill(4) + "-dirty.fits")
            diff = hdu2[0].data[0,0,:,:] - hdu1[0].data[0,0,:,:]

            ## The below skips all flagged channels
            if np.all(diff == 0):
                continue

            ## The below looks at the pixel distribution and does a curve fit
            hist, bins = np.histogram(diff, bins=1500)
            x = []
            for counter1 in range(len(bins)-1):
                x.append(float((bins[counter1] + bins[counter1+1])/2.0))
            pdfOfPixelDist = hist/(float(imgSize)**2.0) #probability density distribution for the pixel amp
            
            def optm(l,q):
                return skew_norm_pdf(q,l[0],l[1],l[2]) - pdfOfPixelDist

            guess = [  0.0025,   11.0,   0.005]
            dataFit = np.asarray(leastsq(optm,guess,(x,)))
            fit = skew_norm_pdf(x,dataFit[0][0],dataFit[0][1],dataFit[0][2])
            cdf = cumulative_distribution_function(x,dataFit[0][0],dataFit[0][1],dataFit[0][2])
    
            ## The below calculates the seedValue and floodfillValue
            seedValue = getSeedValue(cdf,float(args.seedSigma),x)
            floodfillValue = getFloodfillValue(cdf,float(args.floodfillSigma),x)

            if debug is True:
                print("The seedValue is " + str(seedValue) + " and the maximum value is " + str(np.max(diff)))


            ## The below finds the values that satisfy the seedValue
            points = np.asarray(np.where(diff > seedValue))

            for counter2 in range(len(points[0,:])):
                global binaryMaptemp
                binaryMaptemp = np.zeros((imgSize,imgSize)) ## binarymap that stores only the local RFI

                if debug is True:
                    print("RFI detected, seeding .......")

                currentPoint = points[:,counter2]
                floodfill(currentPoint[0],currentPoint[1],floodfillValue,diff,imgSize)
                contourPoints = np.asarray(np.where(binaryMaptemp ==1))

                ## the below breaks out if the current rfi is already been investigated into
                if len(contourPoints[0,:]) is 0:
                    continue
                
                cutout = Cutout2D(diff, (currentPoint[1],currentPoint[0]), (100,100), wcs=wcs)
                ax = plt.subplot(221, projection=cutout.wcs)
                plt.imshow(cutout.data, cmap=plt.cm.inferno, origin="lower")
                plt.grid(color="black",linestyle='-')
                plt.colorbar()

                snr_array = [None]*args.freqChannels
                
                plt.subplot(222)
                
                for f2 in range(args.freqChannels):

                    if debug is True:
                        print("Plotting DSNRS spectrum for RFI at freq " + str(f2))

                    hdutemp1 = fits.open(str(args.obs) +"-2m-" + str(timeStep) + "-" + str(f2).zfill(4) + "-dirty.fits")
                    hdutemp2 = fits.open(str(args.obs) +"-2m-" + str(timeStep+1) + "-" + str(f2).zfill(4) + "-dirty.fits")
                    diff2 = hdutemp2[0].data[0,0,:,:] - hdutemp1[0].data[0,0,:,:]

                    noise_rms = np.sqrt(np.mean(diff2**2.0))

                    signal=0
                    for pointNo in range(len(contourPoints[0,:])):
                        signal+=diff2[contourPoints[0,pointNo],contourPoints[1,pointNo]]

                    signal = signal/float(len(contourPoints[0,:]))
                    snr_array[f2] = signal/noise_rms

                i_array = np.linspace(72.335,103.015,args.freqChannels)
                plt.plot(i_array,snr_array,color="black",linewidth=0.5)
                plt.grid()

                ## the below section plots the contour
                contourImg = Cutout2D(binaryMaptemp, (currentPoint[1],currentPoint[0]), (100,100),wcs=wcs)
                ax = plt.subplot(223,projection=contourImg.wcs)
                plt.imshow(contourImg.data, cmap=plt.cm.inferno, origin="lower")
                plt.grid()
                plt.colorbar()

                ax = plt.subplot(224, projection=wcs)
                plt.imshow(diff, cmap=plt.cm.inferno, origin="lower")
                plt.grid()
                plt.scatter(currentPoint[1],currentPoint[0],s=80,facecolors='none',edgecolors='lime')


                if debug is True:
                    plt.show()

                plt.savefig(str(args.prefix) + "Sigma" + "LOWRES_RFISeeker_timeStep" + str(timeStep).zfill(4) + "_atFreq"+ str(f).zfill(4) + "_andRFINo" + str(counter2).zfill(2) + ".png")
                plt.clf()

        hdun = fits.PrimaryHDU(binaryMap,header=hdu[0].header)
        hdun.writeto(str(args.prefix) + "Sigma" + "RFIBinaryMap-t" + str(timeStep).zfill(4) + ".fits")


if __name__ =="__main__":
    main()
