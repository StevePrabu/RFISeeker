#!/usr/bin/python
from __future__ import division
from astropy.io import fits
import numpy as np
from astropy.wcs import WCS
from astropy.nddata import Cutout2D
import os.path
from argparse import ArgumentParser
import ephem
import time
from scipy.stats import skew
from datetime import datetime, timedelta
from scipy import stats
from scipy.stats import norm
from scipy.optimize import leastsq,curve_fit,minimize
from scipy import special
from scipy.signal import find_peaks

##custom 
from mwassa.imginfo import info
from mwassa.curvefitting import skew_norm_pdf, reqCDF, cumulative_distribution_function, getSeedValue, getFloodfillValue
from mwassa.plotting import intialiseMatplotib




def floodfill(x,y,floodfillValue,diff,imgSize):
    if diff[x,y] >= floodfillValue and binaryMap[x,y] ==0:
        binaryMap[x,y] =1
        binaryMaptemp[x,y] =1
        if 1<x<(imgSize-1) and 1<y<(imgSize-1):
            floodfill(x+1,y,floodfillValue,diff,imgSize)
            floodfill(x,y+1,floodfillValue,diff,imgSize)
            floodfill(x-1,y,floodfillValue,diff,imgSize)
            floodfill(x,y-1,floodfillValue,diff,imgSize)
            floodfill(x-1,y-1,floodfillValue,diff,imgSize)
            floodfill(x+1,y-1,floodfillValue,diff,imgSize)
            floodfill(x-1,y+1,floodfillValue,diff,imgSize)
            floodfill(x+1,y+1,floodfillValue,diff,imgSize)
    return



def main():
	parser = ArgumentParser("Flagger", description="Flagges and plots DSNRS for RFI")
	parser.add_argument('--obs', required=True, help="The observation id")
	parser.add_argument('--freqChannels', required=True,type=int, help="Number of frequency channels to process")
	parser.add_argument('--timeStep', required=True, type=int, help="The timestep at which RFISeeker runs")
	parser.add_argument('--seedSigma', default=8, help="The sigma threshold for RFI seeding" )
	parser.add_argument('--floodfillSigma', default=3, help="The sigma upto which flood fill happens")
	parser.add_argument('--debug', default=False, type=bool,help="Prints out more values and shows figure if ran in debug mode")
	parser.add_argument('--plotSatellites', default=False,type=bool,help="Plots the location of the starlink constellation in a different color")
	parser.add_argument('--imgSize',required=False, type=int, help="The size of the images")
	parser.add_argument('--prefix',required=False,help="The prefix used in the ouputfiles")
	parser.add_argument('--DSNRS', required=False,default=True,help="Disable/Enable DSNRS analysis")
        parser.add_argument('--deltaF',required=False,default=0,type=int,help='The offset it frequency')
	parser.add_argument('--evenTimeStepsOnly',default=False,type=bool, help="enable wokring with even timeSteps for observations like Alouette")
        args = parser.parse_args()
	debug = args.debug

	hdu = fits.open(str(args.obs) + "-2m-" + str(0) + "-" + str(0).zfill(4) + "-dirty.fits")
        imgSize, wcs, header = info(str(args.obs) + "-2m-" + str(0) + "-" + str(0).zfill(4) + "-dirty.fits")
        plt = intialiseMatplotib(debug)

        #below array saves info of all the detections in a given timeStep
        global binaryMap
        binaryMap = np.zeros((imgSize,imgSize))
	global binaryMapOutput
	binaryMapOutput = np.zeros((imgSize,imgSize))
        timeStep = args.timeStep

	

        for f in range(args.freqChannels):
            if timeStep in [0,1,2]:
		break	
		    
            if args.evenTimeStepsOnly is True:
                if not timeStep%2==0:
		    break
	    f += args.deltaF

            if debug is True:
                print("Working in frequency channel " + str(f+1) + "/" + str(args.freqChannels))

            hdu1 = fits.open(str(args.obs) + "-2m-" + str(timeStep) + "-" + str(f).zfill(4) + "-dirty.fits")
	    if args.evenTimeStepsOnly is True:
            	hdu2 = fits.open(str(args.obs) + "-2m-" + str(timeStep+2) + "-" + str(f).zfill(4) + "-dirty.fits")
	    else:
		hdu2 = fits.open(str(args.obs) + "-2m-" + str(timeStep+2) + "-" + str(f).zfill(4) + "-dirty.fits")
            diff = hdu2[0].data[0,0,:,:] - hdu1[0].data[0,0,:,:]

	    std = np.std(diff)
            ## The below skips all flagged channels
            if np.all(diff == 0):
                continue

            ## The below looks at the pixel distribution and does a curve fit
            #hist, bins = np.histogram(diff, bins=1500)
            #x = []
            #for counter1 in range(len(bins)-1):
            #    x.append(float((bins[counter1] + bins[counter1+1])/2.0))
            #pdfOfPixelDist = hist/(float(imgSize)**2.0) #probability density distribution for the pixel amp
            
            #def optm(l,q):
            #    return skew_norm_pdf(q,l[0],l[1],l[2]) - pdfOfPixelDist

            #initStd = skew(pdfOfPixelDist)
	    #guess = [  0.0025,   11.0,   0.005]
            #dataFit = np.asarray(leastsq(optm,guess,(x,)))
            #x2 = np.linspace(np.mean(x), (max(x)+10.0),20000)
            #fit = skew_norm_pdf(x,dataFit[0][0],dataFit[0][1],dataFit[0][2])
            #cdf = cumulative_distribution_function(x2,dataFit[0][0],dataFit[0][1],dataFit[0][2])
	    #finalStd = skew(fit)
	    #conv = True
	    #if abs(finalStd-initStd) > 0.018:
	    #	conv = False
	    
    	    #while conv is False:
	    #	guess = [  0.0025,  np.random.uniform(0.1,15.0,1)[0] ,   0.005]
	    #	dataFit = np.asarray(leastsq(optm,guess,(x,)))
	    #	fit = skew_norm_pdf(x,dataFit[0][0],dataFit[0][1],dataFit[0][2])
       	    #   finalStd = skew(fit)
	    #	if abs(finalStd-initStd) <= 0.018:
  	    #	    conv = True
		
		
            ## The below calculates the seedValue and floodfillValue
            seedValue = float(args.seedSigma)*std
            floodfillValue = float(args.floodfillSigma)*std
            
	    ## The below finds the values that satisfy the seedValue
            points = np.asarray(np.where(diff > seedValue))
	    global binaryMapf
	    binaryMapf = np.zeros((imgSize,imgSize))
	    numberofrfi = 0
            for counter2 in range(len(points[0,:])):
                plt.clf()
		global binaryMaptemp
                binaryMaptemp = np.zeros((imgSize,imgSize)) ## binarymap that stores only the local RFI

                if debug is True:
                    print("RFI detected, seeding .......")

                currentPoint = points[:,counter2]
                floodfill(currentPoint[0],currentPoint[1],floodfillValue,diff,imgSize)
                contourPoints = np.asarray(np.where(binaryMaptemp ==1))

                ## the below breaks out if the current rfi is already been investigated into
                if len(contourPoints[0,:]) is 0:
                    continue
                
                
                cutout = Cutout2D(diff, (currentPoint[1],currentPoint[0]), (100,100), wcs=wcs)
                ax = plt.subplot(221, projection=cutout.wcs)
                plt.imshow(cutout.data, cmap=plt.cm.inferno, origin="lower")
                plt.grid(color="black",linestyle='-')
                plt.colorbar()

                snr_array = [None]*args.freqChannels
                
                if args.DSNRS is True:
                    plt.subplot(222)
                
                    for f2 in range(args.freqChannels):

                        if debug is True:
                            print("Plotting DSNRS spectrum for RFI at freq " + str(f2))

                        hdutemp1 = fits.open(str(args.obs) +"-2m-" + str(timeStep) + "-" + str(f2).zfill(4) + "-dirty.fits")
			if args.evenTimeStepsOnly is True:
                            hdutemp2 = fits.open(str(args.obs) +"-2m-" + str(timeStep+2) + "-" + str(f2).zfill(4) + "-dirty.fits")
                        else:
			    hdutemp2 = fits.open(str(args.obs) +"-2m-" + str(timeStep+1) + "-" + str(f2).zfill(4) + "-dirty.fits")
                        diff2 = hdutemp2[0].data[0,0,:,:] - hdutemp1[0].data[0,0,:,:]
			
			if np.all(diff2 == 0):
				continue

                        noise_rms = np.sqrt(np.mean(diff2**2.0))

                        signal=0
                        for pointNo in range(len(contourPoints[0,:])):
                            signal+=diff2[contourPoints[0,pointNo],contourPoints[1,pointNo]]

                        signal = signal/float(len(contourPoints[0,:]))
                        snr_array[f2] = signal/noise_rms
                    i_array = np.linspace(72.335,103.015,args.freqChannels)
                    plt.plot(i_array,snr_array,color="black",linewidth=0.5)
                    plt.grid()

                    ## the below section plots the contour
                    contourImg = Cutout2D(binaryMaptemp, (currentPoint[1],currentPoint[0]), (100,100),wcs=wcs)
                    ax = plt.subplot(223,projection=contourImg.wcs)
                    plt.imshow(contourImg.data, cmap=plt.cm.inferno, origin="lower")
                    plt.grid()
                    plt.colorbar()

                    ax = plt.subplot(224, projection=wcs)
                    plt.imshow(diff, cmap=plt.cm.inferno, origin="lower")
                    plt.grid()
                    plt.scatter(currentPoint[1],currentPoint[0],s=80,facecolors='none',edgecolors='lime')
                numOfSigPeaks, _ = find_peaks(snr_array, distance=5, height=3)
		if len(numOfSigPeaks) > 1:
                    binaryMapOutput += binaryMaptemp
		    numberofrfi +=1
                else:
                    if debug is True:
                        print("detected RFI is most likely a sidelobe :( ")
                    continue


                if debug is True:
                    plt.show()


                plt.savefig(str(args.prefix) + "Sigma" + "LOWRES_RFISeeker_timeStep" + str(timeStep).zfill(4) + "_atFreq"+ str(f).zfill(4) + "_andRFINo" + str(numberofrfi).zfill(2) + ".png")
                plt.clf()
		binaryMapf += binaryMaptemp
		

        hdun = fits.PrimaryHDU(binaryMapOutput,header=hdu[0].header)
        hdun.writeto(str(args.prefix) + "Sigma" + "RFIBinaryMap-t" + str(timeStep).zfill(4) + ".fits")


if __name__ =="__main__":
    main()
